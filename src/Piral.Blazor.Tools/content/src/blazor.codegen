var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// src/index.ts
var import_path5 = require("path");
var import_fs4 = require("fs");

// src/io.ts
var import_fs = require("fs");
var import_path = require("path");
function copyFiles(assets, target) {
  for (const asset of assets) {
    const fromPath = asset.Identity;
    const toPath2 = (0, import_path.resolve)(target, asset.BasePath !== "/" ? `${asset.BasePath}/${asset.RelativePath}` : asset.RelativePath);
    const toDir = (0, import_path.dirname)(toPath2);
    (0, import_fs.mkdirSync)(toDir, { recursive: true });
    (0, import_fs.copyFileSync)(fromPath, toPath2);
  }
}
function copyAll(forcedFiles, ignoredFiles, source, targetDir) {
  const staticFiles = source.Assets.filter((asset) => forcedFiles.includes(asset.RelativePath) || !ignoredFiles.includes(asset.RelativePath));
  copyFiles(staticFiles, targetDir);
}

// src/piral.ts
var import_fs2 = require("fs");
var import_path2 = require("path");
function getPiralVersion(shellPackagePath2) {
  try {
    const { version } = require(shellPackagePath2).piralCLI;
    if (typeof version !== "string") {
      throw new Error();
    }
    return version;
  } catch {
    try {
      return require("piral-cli/package.json").version;
    } catch {
      throw new Error("The version of the `piral-cli` could not be determined.");
    }
  }
}
function findAppDir(baseFolder, piralName) {
  const appdir2 = (0, import_path2.resolve)(baseFolder, "node_modules", piralName);
  if (!(0, import_fs2.existsSync)(`${appdir2}/app`) && (0, import_fs2.existsSync)(`${appdir2}/dist`)) {
    return `${appdir2}/dist`;
  }
  return appdir2;
}

// src/utils.ts
var import_fs3 = require("fs");
var import_path3 = require("path");
function getAllKeys(manifest, type) {
  return Object.keys(manifest.resources[type] || {});
}
function getUniqueKeys(originalManifest, piletManifest, type) {
  const original = getAllKeys(originalManifest, type);
  const dedicated = getAllKeys(piletManifest, type);
  return dedicated.filter((m) => !original.includes(m));
}
var projExtension = ".csproj";
function getProjName(x) {
  return (0, import_path3.basename)(x).slice(0, -projExtension.length);
}
function diffBlazorBootFiles(appdir2, appname, piletManifest, originalManifest) {
  if (!(0, import_fs3.existsSync)(appdir2)) {
    throw new Error(`Cannot find the directory of "${appname}". Please re-install the dependencies.`);
  }
  return [
    getUniqueKeys(originalManifest, piletManifest, "assembly"),
    getUniqueKeys(originalManifest, piletManifest, "pdb")
  ];
}

// src/version.ts
function isVersionSame(oldVer, newVer) {
  const oldParts = oldVer.split(".");
  const newParts = newVer.split(".");
  const len = Math.min(4, Math.max(oldParts.length, newParts.length));
  for (let i = 0; i < Math.min(2, len); i++) {
    const a = newParts[i];
    const b = oldParts[i];
    if (a !== b) {
      return "incompatible";
    }
  }
  for (let i = 2; i < Math.min(4, len); i++) {
    const a = newParts[i];
    const b = oldParts[i];
    if (a !== b) {
      return "compatible";
    }
  }
  return "match";
}
function stripVersion(x) {
  return x.split("/")[0];
}
function extractBlazorVersion(manifest) {
  var _a;
  return ((_a = Object.keys(manifest.resources.runtime).map((x) => x.match(/^dotnet\.(.*?)\.js/)).find(Boolean)) == null ? void 0 : _a[1]) || "0.0.0";
}
function checkBlazorVersion(piletBlazorVersion, appshellBlazorVersion) {
  const versionMatch = isVersionSame(appshellBlazorVersion, piletBlazorVersion);
  if (versionMatch === "incompatible") {
    throw new Error(`The Blazor versions of your pilet and Piral Instance are incompatible:
     - Piral Instance Blazor version = ${appshellBlazorVersion}
     - Pilet Blazor version = ${piletBlazorVersion}`);
  } else if (versionMatch === "compatible") {
    console.warn(`The Blazor versions of your pilet and Piral Instance do not match, but seem to be compatible:
      - Piral Instance Blazor version = ${appshellBlazorVersion}
      - Pilet Blazor version = ${piletBlazorVersion}`);
  }
}

// src/constants.ts
var targetFramework = "**MSBUILD_TargetFramework**";
var targetFrameworkAlt = "**MSBUILD_TargetFrameworkMoniker**";
var configFolderName = "**MSBUILD_ConfigFolder**";
var isRelease = process.env.NODE_ENV === "production";
var configuration = isRelease ? "Release" : "Debug";
var action = isRelease ? "publish" : "build";
var variant = isRelease ? "release" : "debug";
var bbjson = "blazor.boot.json";
var pajson = "project.assets.json";
var pjson = "package.json";
var analyzer = "Piral.Blazor.Analyzer";
var setupfile = "setup.tsx";
var teardownfile = "teardown.tsx";
var swajson = `staticwebassets.${action}.json`;
var ignoredFromWwwrootStandalone = [
  "index.html",
  "favicon.ico",
  "icon-192.png"
];
var ignoredFromWwwroot = [
  ...ignoredFromWwwrootStandalone,
  "_framework/"
];

// src/targets.ts
function createAllRefs(internaltargets, externalTargets) {
  const refs = /* @__PURE__ */ new Set();
  const createExternalRefs = (fileName) => {
    if (!fileName) {
      return;
    }
    const deps = externalTargets[fileName];
    if (!deps || deps.length === 0) {
      return refs.add(fileName);
    }
    deps.forEach(createExternalRefs);
    refs.add(fileName);
  };
  for (const [fileName, deps] of Object.entries(internaltargets)) {
    deps.forEach(createExternalRefs);
    refs.add(fileName);
  }
  return [...refs];
}
function defineTargets(uniqueDependencies, projectAssets) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const isNotSharedDep = (x) => typeof x === "string" && uniqueDependencies.includes(x);
  const targets = (_c = (_a = projectAssets.targets) == null ? void 0 : _a[targetFrameworkAlt]) != null ? _c : (_b = projectAssets.targets) == null ? void 0 : _b[targetFramework];
  const getDllName = (projectId) => {
    var _a2, _b2, _c2, _d2;
    const target = Object.entries(targets).find((t) => stripVersion(t[0]) === projectId);
    const compile = (_a2 = target == null ? void 0 : target[1]) == null ? void 0 : _a2.compile;
    if (!compile) {
      return void 0;
    }
    return ((_d2 = ((_c2 = (_b2 = Object.keys(compile)) == null ? void 0 : _b2[0]) != null ? _c2 : "").split("/").pop()) != null ? _d2 : "").replace(".dll", "");
  };
  const filterDeps = (deps) => deps.map(getDllName).filter((d) => !!d && isNotSharedDep(d));
  const externalTargets = Object.entries(targets).map(([id, data]) => [getDllName(stripVersion(id)), data]).filter(([dllName, _]) => isNotSharedDep(dllName)).map(([dllName, data]) => [
    dllName,
    filterDeps(Object.keys(data.dependencies || {}))
  ]).reduce((acc, [k, v]) => ({ [k]: v, ...acc }), {});
  const projectDependencies = filterDeps(Object.keys((_g = (_f = (_e = (_d = projectAssets.project) == null ? void 0 : _d.frameworks) == null ? void 0 : _e[targetFramework]) == null ? void 0 : _f.dependencies) != null ? _g : {}));
  const rawReferences = (_l = (_k = (_j = (_i = (_h = projectAssets.project) == null ? void 0 : _h.restore) == null ? void 0 : _i.frameworks) == null ? void 0 : _j[targetFramework]) == null ? void 0 : _k.projectReferences) != null ? _l : {};
  const projectReferences = Object.keys(rawReferences).map(getProjName);
  const projectName = (_n = (_m = projectAssets.project) == null ? void 0 : _m.restore) == null ? void 0 : _n.projectName;
  const internalTargets = {
    [projectName]: [...projectDependencies, ...projectReferences]
  };
  return [internalTargets, externalTargets];
}
function createAllTargetRefs(uniqueDependencies, projectAssets) {
  const targets = defineTargets(uniqueDependencies, projectAssets);
  return createAllRefs(...targets);
}

// src/project.ts
var import_glob = __toESM(require("glob"));
var import_path4 = require("path");
var import_util = require("util");
var import_child_process = require("child_process");
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var matchVersion = /\d+\.\d+\.\d+/;
function getProjectName(projectFolder) {
  return new Promise((resolve4, reject) => {
    (0, import_glob.default)(`${projectFolder}/*.csproj`, (err, matches) => {
      if (!!err || !matches || matches.length == 0)
        return reject(new Error(`Project file not found. Details: ${err}`));
      if (matches.length > 1)
        return reject(new Error(`Only one project file is allowed. You have: ${JSON.stringify(matches, null, 2)}`));
      return resolve4((0, import_path4.basename)(matches[0]).replace(".csproj", ""));
    });
  });
}
async function buildSolution(cwd) {
  console.log(`Running "${action}" on solution in ${configuration} mode...`);
  await execAsync(`dotnet ${action} --configuration ${configuration}`, {
    cwd
  });
}
async function checkInstallation(piletBlazorVersion, shellPackagePath2) {
  try {
    require.resolve("piral-blazor/package.json");
    require.resolve("blazor/package.json");
  } catch {
    console.warn("The npm packages `blazor` and `piral-blazor` have not been not found. Installing them now...");
    const piralVersion = getPiralVersion(shellPackagePath2);
    const result = matchVersion.exec(piletBlazorVersion);
    if (!result) {
      throw new Error("Could not detect version of Blazor. Something does not seem right.");
    }
    const [npmBlazorVersion] = result;
    const [blazorRelease] = npmBlazorVersion.split(".");
    const installCmd = `npm i blazor@^${blazorRelease} piral-blazor@${piralVersion}`;
    await execAsync(installCmd);
  }
}
async function analyzeProject(blazorprojectfolder2) {
  const projectName = await getProjectName(blazorprojectfolder2);
  const command = `dotnet ${analyzer} --base-dir "${blazorprojectfolder2}" --dll-name "${projectName}.dll" --target-framework "${targetFramework}" --configuration "${configuration}"`;
  const { stdout, stderr } = await execAsync(command);
  if (stderr) {
    throw new Error(stderr);
  }
  const { routes, extensions } = JSON.parse(stdout.trim());
  return { routes, extensions };
}

// src/components.ts
function toPageRegistration(route) {
  return `app.registerPage("${toPath(route)}", app.fromBlazor("page-${route}"));`;
}
function toExtensionRegistration([fqn, ids]) {
  return ids.map((id) => `app.registerExtension("${id}", app.fromBlazor("extension-${fqn}"));`).join("\n");
}
function toPath(route) {
  return route.replace(/\{([\w?]*)([:*])?([^\/\{\}]*)\}/g, (...groups) => groups[2] != "*" ? `:${groups[1]}` : "*");
}

// src/snippets.ts
var definePathCode = `function computePath() {
  try {
    throw new Error();
  } catch (t) {
    const e = ('' + t.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);
    if (e) {
      return e[0].replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)\\/[^\\/]+$/, '$1') + '/';
    }
  }
  return '/';
}
const path = computePath();
`;
var standaloneRemapCode = `
  app.defineBlazorReferences = defineBlazorReferences;
  app.defineBlazorOptions = () => {};
  app.fromBlazor = fromBlazor;
  app.releaseBlazorReferences = releaseBlazorReferences;
`;
var fallbackPiletCode = `export function registerPages(...args) {
  console.warn('${__filename}: \`registerPages\` was called, but no Blazor routes were found.');
}

export function registerExtensions(...args) {
  console.warn('${__filename}: \`registerExtensions\` was called, but no Blazor extensions were found.');
}

export const routes = [];

export const paths = [];`;
function makePiletHead(allImports, getPiralBlazorApiCode, setupPiletCode, teardownPiletCode, registerDependenciesCode, registerOptionsCode) {
  return `
    ${allImports.join("\n")}

    ${definePathCode}
    
    ${getPiralBlazorApiCode}
    ${setupPiletCode}
    ${registerDependenciesCode}
    ${registerOptionsCode}
    ${teardownPiletCode}
  `;
}
function makePiletCode(routes, extensions) {
  return `
    export function registerPages(app) { 
      ${routes.map(toPageRegistration).join("\n")}
    }

    export function registerExtensions(app) {
      ${Object.entries(extensions).map(toExtensionRegistration).join("\n")} 
    }

    export const routes = ${JSON.stringify(routes)};

    export const paths = ${JSON.stringify(routes.map(toPath))};
  `;
}

// src/index.ts
var piralPiletFolder = (0, import_path5.resolve)(__dirname, "..");
var rootFolder = (0, import_path5.resolve)(piralPiletFolder, "..", "..");
var blazorfolderName = (0, import_path5.basename)(piralPiletFolder);
var blazorprojectfolder = (0, import_path5.resolve)(rootFolder, blazorfolderName);
var piralconfigfolder = (0, import_path5.resolve)(blazorprojectfolder, configFolderName);
var objectsDir = (0, import_path5.resolve)(blazorprojectfolder, "obj");
var pafile = (0, import_path5.resolve)(objectsDir, pajson);
var swafile = (0, import_path5.resolve)(objectsDir, configuration, targetFramework, swajson);
var project = require((0, import_path5.resolve)(piralPiletFolder, pjson));
var appdir = findAppDir(piralPiletFolder, project.piral.name);
var shellPackagePath = (0, import_path5.resolve)(appdir, pjson);
var appFrameworkDir = (0, import_path5.resolve)(appdir, "app", "_framework");
module.exports = async function() {
  const targetDir = this.options.outDir;
  if (isRelease || !(0, import_fs4.existsSync)(pafile) || !(0, import_fs4.existsSync)(swafile)) {
    try {
      await buildSolution(blazorprojectfolder);
    } catch (err) {
      throw new Error(`Something went wrong with the Blazor build.
Make sure there is at least one Blazor project in your solution.
Seen error: ${err}`);
    }
  }
  const projectAssets = require(pafile);
  const staticAssets = require(swafile);
  const manifestSource = staticAssets.Assets.find((m) => m.AssetRole === "Primary" && m.RelativePath === "_framework/blazor.boot.json");
  if (!manifestSource) {
    throw new Error(`Could not find the "blazor.boot.json" in ${swafile}. Something seems to be wrong.`);
  }
  const piletManifest = require(manifestSource.Identity);
  const bbAppShellPath = (0, import_path5.resolve)(appFrameworkDir, bbjson);
  const bbStandalonePath = `blazor/${variant}/wwwroot/_framework/${bbjson}`;
  const blazorInAppshell = (0, import_fs4.existsSync)(bbAppShellPath);
  const piletBlazorVersion = extractBlazorVersion(piletManifest);
  let dlls = [];
  let pdbs = [];
  if (blazorInAppshell) {
    console.log("The app shell already integrates `piral-blazor` with `blazor`.");
    const appShellManifest = require(bbAppShellPath);
    const appshellBlazorVersion = extractBlazorVersion(appShellManifest);
    [dlls, pdbs] = diffBlazorBootFiles(appdir, project.piral.name, piletManifest, appShellManifest);
    checkBlazorVersion(piletBlazorVersion, appshellBlazorVersion);
    copyAll([...dlls, ...pdbs], ignoredFromWwwroot, staticAssets, targetDir);
  } else {
    console.log("The app shell does not contain `piral-blazor`. Using standalone mode.");
    await checkInstallation(piletBlazorVersion, shellPackagePath);
    const originalManifest = require(bbStandalonePath);
    [dlls, pdbs] = diffBlazorBootFiles(appdir, project.piral.name, piletManifest, originalManifest);
    copyAll([...dlls, ...pdbs], ignoredFromWwwrootStandalone, staticAssets, targetDir);
  }
  const allImports = [];
  if (!blazorInAppshell) {
    allImports.push(`import { defineBlazorReferences, fromBlazor, releaseBlazorReferences } from 'piral-blazor/convert';`);
  }
  const getPiralBlazorApiCode = `export function initPiralBlazorApi(app) {
    ${blazorInAppshell ? "" : standaloneRemapCode}
  }`;
  const uniqueDependencies = dlls.map((f) => f.replace(".dll", ""));
  const refs = createAllTargetRefs(uniqueDependencies, projectAssets);
  const registerDependenciesCode = `export function registerDependencies(app) { 
    const references = [
      ${refs.map((ref) => `path + "${ref}.dll"`).join(",")}, 
      ${pdbs.map((pdb) => `path + "${pdb}"`).join(",")}
    ]; 
    app.defineBlazorReferences(references);
  }`;
  const registerOptionsCode = `export function registerOptions(app) {
    app.defineBlazorOptions({ resourcePathRoot: path });
  }`;
  const setupFilePath = (0, import_path5.join)(piralconfigfolder, setupfile).replace(/\\/g, "/");
  const setupFileExists = (0, import_fs4.existsSync)(setupFilePath);
  if (setupFileExists) {
    allImports.push(`import projectSetup from '${setupFilePath}';`);
  }
  const setupPiletCode = `export const setupPilet = ${setupFileExists ? "projectSetup" : "() => {}"}`;
  const teardownFilePath = (0, import_path5.join)(piralconfigfolder, teardownfile).replace(/\\/g, "/");
  const teardownFileExists = (0, import_fs4.existsSync)(teardownFilePath);
  if (teardownFileExists) {
    allImports.push(`import projectTeardown from '${teardownFilePath}';`);
  }
  const teardownPiletCode = `export const teardownPilet = ${teardownFileExists ? "projectTeardown" : "() => {}"}`;
  const headCode = makePiletHead(allImports, getPiralBlazorApiCode, setupPiletCode, teardownPiletCode, registerDependenciesCode, registerOptionsCode);
  try {
    const { routes, extensions } = await analyzeProject(blazorprojectfolder);
    const standardPiletCode = makePiletCode(routes, extensions);
    return `
      ${headCode}

      ${standardPiletCode}
    `;
  } catch (err) {
    console.error(err);
    return `
      ${headCode}    

      ${fallbackPiletCode}
    `;
  }
};
